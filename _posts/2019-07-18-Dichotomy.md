---
layout: post
title: "一招搞定95%的二分算法题"
date: 2019-07-18 19:27:34 +0800

categories: 
    - Algorithms
tags: 
    - dichotomy
image: assets/images/6.jpg
---

### 二分算法的本质

我们经常把二分和单调性联系起来，实际上，二分和单调性并不是直接相关的。或者说，具有单调性的问题可以用二分来解决，而二分并不是只能解决具有单调性的问题，也就是说，单调性是二分的充分条件而非必要条件。

那么，更加宽泛的来看，到底什么样的问题可以用二分来解决呢？

可以这样描述，可以用二分来解决的问题具有这样的性质：

在区间[l, r]上存在一种性质，能够将区间一分为二，一部分满足性质，另一部分不满足。

对于区间是整数的二分问题而言，存在两种情况：也就是二分的边界点属于左半边的区间还是右半边的区间。

如图所示：

![dichotomy_1]({{site.url}}/assets/images/dichotomy_1.png)

在这个图中，x是红色的，也就是说分界点x处于左边的区间

![dichotomy_2]({{site.url}}/assets/images/dichotomy_2.png)

在这个图中，x是绿色的，也就是说分界点x处在右边的区间

对应这两种情况，代码有所差异。因此可以衍生出两个版本的代码模板：

首先，对于两种情况而言，基本的二分写法是不变的，算法每次迭代去区间点，即
```cpp
int mid = (l + r) / 2
```
然后检查中点是否满足性质(这里假设如果一个点是红色则check返回true)
```cpp
bool check(mid)
```
1. 对于图一，也就是x属于红色的情况，这时如果check(mid) == true，那么mid处在红色区间，
那么分界点将会在mid右边，但是考虑到分界点也处在红色区间，因此mid也有可能就是
分界点，那么新的区间应该是[mid, r]；相应地，如果check(mid)为false，那么说明mid处
在绿色区间，那么分界点应该在mid的左边，由于分界点x属于红色，那么mid不可能是分界点
，因此心的区间是[l, mid-1]代码如下：
```cpp
while (l < r) {
    int mid = l + r + 1 >> 1;
    if (check(mid))
        l = mid;
    else
        r = mid - 1;
}
```

2. 对于图二，也就是x属于绿色的情况则和图一的情相反：如果check(mid)为true，
说明mid是红色，那么分界点将在将在mid的右边，但是由于分界点x是绿色，
所以mid不可能是分界点，因此新的区间是[mid + 1, r]；check(mid)为false的
情况以此类推，具体代码如下：
```cpp
while (l < r) {
    int mid = l + r >> 1;
    if (check(mid)) 
        l = mid + 1;
    else
        r = mid;
}
```

注意到两个模板有一个细微的差别：对于图一，也就是x是红色的情况，在计算mid的时候
写的是
```cpp
mid = l + r + 1 >> 1;
```
\>>表示位运算的右移运算，右移一位即除以2，在除以2之前加+相当于上取整，这是什么操作？

现在假设r = l + 1，也就是整个区间只有两个元素，如果采用下取整的除法（C++默认），
那么得到的此时$$ mid = \lfloor\frac{l + r}{2}\rfloor = \lfloor\frac{2l + 1}{2}\rfloor = l $$，
新的区间[mid, r]就是[l, r]，也就是说区间没有得到更新，算法将陷入死循环。

实际上，熟练以后并不需要对于这两个模板分别记忆，只需要注意一下，写代码的时候如果遇到
```
l = mid
```
的时候，计算mid的时候加1即可。

熟练使用这两个模板可以应对95%的整数二分算法题，剩下的5%的题属于不需要满足前文所提的一分为二的性质也可以使用二分的方法来解决，但是这类问题没有固定模板，需要见机行事。

声明
> 本文所用的代码模板和思想均来源于[acwing](https://www.acwing.com)，版权归y总所有
