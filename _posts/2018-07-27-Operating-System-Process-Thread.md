---
layout: post
title: "操作系统--进程"
date: 2018-07-27 09:27:34 +0800

categories: 
    - Opreating System
tags: 
    - process
    - thread
image: assets/images/8.jpg
---

## 进程

### 1. 为什么引入进程？

为了解释进程的引入，我们先了解一个概念，那就是多道程序系统。

> 多道程序系统是指系统中同时有两个或两个以上的程序处于开始执行但尚未结束的状态。

多道程序系统呈现出一种宏观上并行，微观上串行的特点。这样的设计是为了提高CPU的利用率，假如系统中只有一个程序在运行，如果这个程序是一个I/O密集型的程序，那么CPU多数时间将处于空闲状态。如果能够在一个程序进行I/O的时候，暂停这个程序，转去执行另一个程序，那么就可以大大提高CPU的运行效率。

为了描述这种并发执行的程序，于是就引入了进程的概念。进程的引入实现了操作系统的两大基本特性--并发性和共享性。

### 2. 进程是什么？

从不同的角度来看，进程可以有不同的定义：
1. 进程是程序的一次执行过程
2. 进程是一个程序及其数据在处理机上顺序执行时所发生的活动
3. 进程时具有独立功能的程序在一个数据集合上运行的过程，是系统进行资源分配和调度的一个独立单位

总结来说，进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。

进程是动态的，具有一定的生命周期。多个进程实体可以同时存在与内存中，并且能在一段时间内同时运行（注意是一段时间内，而不是同一时刻同时运行，因为这里的并行在微观上还是串行的）。进程之间是独立的，它们轮换着获得CPU时间进行执行，并且轮换顺序是事先未知的。

这里所说的资源，其实说到底就是CPU时间，即时间片，也就是说，进程是时间片分配的单位，又或者说，进程是一段CPU时间的描述。

那么，进程实体又是什么？

### 3. 进程实体

为了描述进程，操作系统引入了一种数据结构--PCB(Process Control Block, 即进程控制块)。进程和PCB是一一对应的，系统中有一个进程就有一个PCB，有一个PCB就代表有一个进程存在。PCB是进程存在的唯一标识，也就是说，没有响应的PCB，进程就不存在。但是，PCB还不是进程实体，PCB只是系统对进程的一个描述。进程实体由**程序段**、**数据段**和**PCB**组成，进程实体也被称为进程映像。进程的创建实际上就是创建进程映像中的PCB，进程的销毁就是销毁进程的PCB。

PCB主要包含进程描述信息、进程控制信息和进程所拥有的资源和使用CPU现场信息三类信息。

### 4. 进程的状态和转换

前文提到，进程是动态的，并且进程之间相互制约，因此，在进程的生命周期中，其状态是不断变化的。

进程的三种基本状态：
1. 运行态(Running)：占有CPU，并在CPU上运行；
2. 就绪态(Ready)：已经具备运行条件，但是因未获得CPU时间而暂时无法运行；
3. 阻塞态(Blocked)：或称等待态(Waiting)，等待某一事件而暂时不能运行

基本状态的转换如同所示：

![process state switching]({{site.url}}/assets/images/process-state-1.jpg)

注意：由运行态既可以转为就绪态，也可转为阻塞态，这两者有何区别？从运行态转为就绪态主要有两种情况，一是进程的时间片用完了；二是在可剥夺的的系统中，由更高优先级的进程进入就绪队列从而抢占了当前进程的CPU时间。而从运行态转向阻塞态则是进程正在等待某个事件的发生，比如等待I/O操作完成，这一过程是主动的。另外，进程从阻塞态转为就绪态是需要其他进程协助的，是被动的过程。

此外还有：
4. 创建态：进程正在被创建尚未进入就绪态。进程创建的大致过程：首先申请一个空白的PCB，填写默认信息，然后系统分配所需资源，最后将进程状态变为就绪态。
5. 终止态：进程正在从系统中消失，可能是正常结束也可能是异常退出，系统需要回收相关资源。

### 5. 进程控制

为了对进程进行管理，系统需要进程控制。进程控制完成进程创建、销毁，进程状态转换等功能，由具有特定功能的原语完成。

原语(Primitive)，也称为原子操作(atomic)，是不可分割或不可打断的操作。

对于通常的进程而言，其创建、销毁及要求系统设备完成的I/O操作，都是利用系统调用而进入内核，再由内核中的相应处理程序予以完成的。

#### 进程创建

1. 分配唯一标识和PCB；
2. 分配地址空间；
3. 初始化PCB(填入默认值)；
4. 设置相应的队列指针(比如将新创建的进程加入到就绪队列的链表中)。

允许一个进程创建另一个进程，此时创建者被称为**父进程**，被创建者被称为**子进程**。子进程可以继承父进程的资源，子进程撤销时应将中父进程那里获得的资源归还给父进程，父进程销毁时必须同时销毁其所有子进程。

UNIX系统中有两种创建进程的有两种方式

1. fork(): 通过复制父进程来创建子进程；
2. exec(): 通过一系列系统调用，用一段新的程序代码覆盖原来的地址空间来实现进程执行代码的转换。

通常一个进程的创建和执行的过程用下图来表示

![fork-exec-exit-wait]({{site.url}}/assets/images/fork-exec-exit-wait.png)

具体而言fork的过程可以如下描述：
1. 为子进程分配一个空闲的PCB；
2. 分配给子进程唯一的pid；
3. 以**一次一页**的方式复制父进程的地址空间；
4. 从父进程继承共享资源，如打开的文件，当前的工作目录等；
5. 将子进程的状态设为就绪，插入就绪队列中；
6. 对子进程返回标识符0；
7. 向父进程返回子进程pid。

首先，注意到fork是以一次一页的方式完全复制父进程的地址空间，而创建子进程的目的是为了让子进程执行不同于父进程的任务，完全复制的方式，子进程通常也不上，并且通常会调用exec()覆盖复制的内容，因此，UNIX的fork效率比较低。Linux使用Copy-On-Write的技术改进了这一缺点，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。

请看如下代码示例：
```c
#include <sys/types.h>
#include <stdio.h>
#include <unistd.h>

void main(int argc, char* argv[]) {

int var;

pid_t pid;
    pid = fork();
    if (pid < 0) {
        fprintf(stderr,"fork faild");
        exit(-1);
    }
    else if (pid == 0) {
        printf("address of var in child: %p\n", &var);
    }
    else {
        wait(NULL);
        printf("address of var in parent: %p\n", &var);
    }
}
```
fork()执行完以后有两个地址空间，两个空间中pid的值不一样，可以此在代码中区分当前是父进程还是子进程。

这段代码的输出为：
```
address of var in child: 0x7fffcf21a1b0
address of var in parent: 0x7fffcf21a1b0
```
可以看到，在父进程和子进程中变量var的地址都是0x7fffcf21a1b0，也就是说，同一程序中同一个变量在不同的进程中其地址是一样的。这是因为，系统为每个进程分配独立地址空间，而在进程内部所见见到的只是逻辑地址，或者说相对地址，而非绝对地址。

#### 进程终止

1. 回收进程所占用的资源(如关闭所打开的文件、断开网络连接、回收分配的内存等等)；
2. 撤销该进程的PCB。

引起进程终止的事件主要有：正常结束，进程完成指定任务退出运行；异常终止，发生了某些异常事件使得进程无法继续运行，比如存储区越界、保护错、非法指令、特权指令错、I/O故障等；

#### 进程阻塞和唤醒

进程阻塞是主动发生的，是等待某个事件的发生，因此需要进程自己执行阻塞原语已进入阻塞状态。

1. 找到将要被阻塞的进程标识对应的PCB；
2. 若该进程为运行态，保存现场，将其状态变为阻塞态，停止运行；
3. 将该PCB插入对应事件的等待队列。

当进程等待的事件发生时，需要由相关进程调用唤醒原语，将等待该事件的进程唤醒。

1. 在该事件的等待队列中找到相应的PCB；
2. 将其移出等待队列，并将状态改为就绪态；
3. 将该PCB插入就绪队列，等待CPU下一次临幸。

#### 进程切换

进程切换是指处理机从一个进程的运行转到下一个进程上运行的过程。

1. 保存处理机上下文，包括程序计数器和其他寄存器；
2. 更新PCB信息；
3. 将PCB移入相应的队列，如就绪队列或相应事件的等待队列；
4. 选择下一个要执行的进程，并更新PCB；
5. 更新内存的数据结构；
6. 恢复处理机上下文。

### 6. 进程的通信

待续


